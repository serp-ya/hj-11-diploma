Дипломный проект курса JavaScript
===

`Прим. Back-end часть сайта располагается на herokuapp, который переходит в режим sleep при долгом "простое". Поэтому, при первичном обращении к GithubPages может показаться, что что-то сломалось, т.к. товары на страницу будут загружаться долго`

Демонстрация:
+ Страница сайта
https://serp-ya.github.io/hj-11-diploma/
+ Страница админа
https://serp-ya.github.io/hj-11-diploma/admin/

В рамках дипломной работы по курсу Нетологии "JavaScript в браузере: создаем интерактивные веб-страницы" была выбрана задача - реализовать функционал интернет-магазина:

1. Загрузка товаров в виде `JSON-объектов` с удалённого сервера с помощью `REST API`
2. Парсинг входящих объектов и генерация HTML-разметки с помощью `DOM API`
3. Добавление\удаление товаров из корзины с помощью Back-end части приложения, основываясь на сессиях с помощью `Cookie`
4. Создание административной странички сайта с возможностью отвечать на чат-сообщения, получаемые через `WebSocket-соединение`
5. Реализовать поисковую строку на сайте с возможностью голосового поиска, основываясь на `MediaStream Recording API` технологии Яндекса `SpeechKit`

## Проектирование

Если опускать этап настройки Back-end части моего проекта, то на этапе проектирования Front-end части я выяснил, что для более качественной реализации поставленных задач, мне необходимо:
+ Найти и подготовить HTML-шаблон
+ Настроить маршрутиризатор (Класс Router)
+ Сделать шаблонизатор (Класс TemplateEngine)
+ Создать схемы страниц для шаблонизации
+ Реализовать функционал корзины
+ Сделать возможность отображения по 6, 9 и 12 товаров на странице
+ Настроить пагинацию
+ Разделить чаты на Клиентов и Администратора
+ Настроить Яндекс SpeechKit API
+ Разбить отдельные управляемые элементы на компоненты 
+ Настроить события на компонентах

### Подготовка html-шаблона

Для придания достойного внешнего вида и сокращения энерго-временных затрат на вёрстку, для реализации учебного проекта были взяты страницы шаблона `htmlnewlook` с сайта `ThemeForest.net`, а именно страницы:
1. Вывод товаров в сетке - http://htmlnewlook.justthemevalley.com/shop_grid.html
2. Корзина товаров - http://htmlnewlook.justthemevalley.com/shopping_cart.html
3. Поиск товаров - http://htmlnewlook.justthemevalley.com/shop_list.html
4. Просмотр конкретного товара - http://htmlnewlook.justthemevalley.com/single_product.html

Далее, шаблон был очищен от ссылок, верхнее меню, правый сайдбар и ссылки в футере ведут на '/' страницу. Были удалены все `JavaScript` файлы и набор товаров был переведён в JSON формат и погружён на сервер.

## Роутинг

Для придания более динамичного вида проекту, мною был написан не сложный роутер, который выполняет различные функции при разных URL а адресной строке, основывается на событии `hashchange`

### Класс `Router`

Файл `./js/Router/Router.js`

На создание роутинга по такому принципу меня вдохновила статья зарубежного коллеги Krasimir Tsonev, который в своём блоге рассказывает, как он готовит собственный фреймворк на `JavaScript`. Большая часть кода роутера взята из его примеров, но очищена от лишнего кода и доработана в соответствии с задачей проекта.

Конструктор класса не принимает аргументов и создаёт экземпляр с следующими полями:
+ `routes`
+ `root`

И обладает следующими методами:
+ `getFragment()`
+ `clearSlashes(path)`
+ `add(re, handler)`
+ `check(f)`
+ `listen()`
+ `navigate(path)`
+ `pickUpLinks()`

(при эксплуатации класса возникла необходимость создать вспомогательную функцию `sendLinkToRouter`, которая используется, как обработчик события клика по ссылке и создана с целью избежания утечки памяти)

#### Поле `routes` 
Хранит в себе все обрабатываемые адреса, добавленные методом `add()`.

#### Поле `root` 
Хранит в себе адрес корня сайта, от которого рассчитываются все заданные маршруты.

#### Метод `getFragment()`
Служит вспомогательной функцией, которая получает фрагмент того маршрута, на котором пользователь находится в данный момент и использует другой метод класса - `clearSlashes()`. Не принимает аргументов.

#### Метод `clearSlashes(path)`
Метод очищает полученный URI от слешей в начале и конце, и возвращает очищенную строку. Принимает 1 аргумент - URI без домена, порта и протокола.

#### Метод `add()`
Метод добавляет в массив поля `routes` объект и возвращает обновлённый экземпляр класса.

Принимает 2 аргумента:
+ `re` - маршрут
+ `handler` - обработчик маршрута

По умолчанию, если первым аргументом передана функция, то она используется, как обработчик для роута, относящегося к корневому маршруту.

#### Метод `check(f)`
Метод служит для того, чтобы проверить изменения на странице. Принимает 1 не обязательный аргумент - фрагмент урл, который необходимо проверить, находит его в массиве поля `routs` данного экземпляра класса и вызывает его обработчик к данному маршруту.

#### Метод `listen()`
Инициализирует прослушку события `hashchange` на глобальном объекте `window`. При изменении хеша, передаёт новый хеш в метод класса `check()`. Добавлен таймаут в 100 миллисекунд, чтобы событие не наступало слишком часто, иначе возможны проблемы с рендерингом страниц при срабатывании редиректа.

#### Метод `navigate(path)`
Метод производит подмену хеша в адресной строке. Используется для обработки кликов по ссылкам.

#### Метод `pickUpLinks()`
Инициализирует прослушивание кликов по глобальному DOM-элементу `body`, делегирует событие только на тег `a`, на который было произведено нажатие.

### Настройки класса `Router`

Создание и настройка экземпляра класса производится в отдельном файле `./js/Router/Router.config.js`
Здесь определен корневой элемент приложения, он имеет идентификатор `app`, внутри которого будет отображаться весь контент, обрабатываемый нашим маршрутиризатором. Так же, реализовано два метода: `appBlock.makeEmpty` - очищает корневой элемент приложения от всех потомков и `appBlock.renderPage(domElements)` - принимает на себя DOM-элементы, которые необходимо отрендерить внутри блока приложения, предварительно очистив его.

Инициализирована глобальная переменная `window.howMuchProductsShow`, которая, по умолчанию, равна 6 и служит для определения количества товаров, выводимых при рендеринге на странице.

Настройка самого экземпляра класса `Router` происходит после наступления события `DOMContentLoaded`, чтобы всё DOM-дерево было успешно сформировано и все скрипты подключены к документу.

По умолчанию, при заходе на сайт, роутер перенаправляет на страницу `/page/1`, где выводится первая часть товаров. Товары загружаются в JSON формате с удалённого сервера. Сервер настроен таким образом, что при обращении к адресу `http://localhost:3000/api/v1/goods` мы получим не больше 6 товаров. 

Мы можем передать следующие параметры в строке запроса:
+ limit - ограничивает кол-во отдаваемых товаров за 1 запрос
+ offset - показывает, сколько нужно пропустить товаров от начала списка
+ count - возвращает только общее кол-во товаров (необходимо для пагинации)
+ search - осуществляет поиск по переданным словам (не по запросу целиком, а по каждому переданному слову)

Обрабатываются следующие виды адресов:
+ `/goods/:goodId`, где goodId - числовой идентификатор товара. Служит для просмотра конкретных товаров
+ `/cart/` - отображает корзину товаров
+ `/page/:pageNum`, где pageNum - числовой идентификатор страницы. Служит, как параметр offset, при обращении к API и нужен для пагинации (если она требуется)
+ `/search/` - для отображения результатов поиска

Каждый роут добавлен с помощью метода `add()` и использует Шаблонизатор.

Все используемые URL вынесены в отдельный файл `./js/Router/Router.urls.js`

## Шаблонизация страниц

Идея создания шаблонизатора пришла сразу, т.к. использование DOM API в классическом его представлении превращается в тяжелочитаемый и трудноподдерживаемый код. Пропадает удобство использования и усложняется масштабируемость проектов.


### Класс `TemplateEngine`

Файл `./js/TemplateEngine/TemplateEngine.js`

Конструктор класса принимает 1 аргумент, путь до папки с схемами шаблонов, и создаёт экземпляр с следующими полями:
+ `schemasFolder`
+ `schemas`

Обладает следующими методами:
+ `addSchema(schemaObject)`
+ `renderPage(schema, renderedData)`
+ `checkVariable(partOfContent)`
+ `parseVariable(partOfContent)`
+ `pickUpDataFromVariable(partOfContent)`
+ `checkCondition(partOfContent)`
+ `parseCondition(partOfContent)`
+ `fulfillCondition(condition, dataSource)`
+ `renderPagination(itemsCount, currentPage)`

#### Требования к JSON-схемам

К JSON-схемам есть требования:
1. Корневой элемент должен быть объектом
2. Названия тегов передаются в виде строки в поле `tagName`
3. Названия классов передаются либо строкой, либо массивом строк в поле `className`
4. Атрибуты передаются в виде объекта, где название поля - имя атрибута, а значение - его значение, передаются в поле `attributes`
5. Если в теге должен быть id, то он передаётся в виде строки отдельным полем `id`
6. Контент тега передаётся в поле `content` в виде строки, тогда будет подставлен, как textNode, либо в виде объекта, либо в виде массива строк/объектов. Вложенные друг в друга теги передаются объектом в поле `content`

#### Метод `addSchema()`
При создании экземпляра класса TemplateEngine я указываю путь до JSON-схем с описанием наших страничек сайта, чтобы сократить урлы при добавлении каждой схемы. После создания экземпляра класса, нужно добавить объекты схем с двумя полями:
1. `name`
2. `url`

Это производится методом `addSchema()` в файле `./js/TemplateEngine/TemplateEngine.config.js`. После добавления схем, из названия и пути к ним хранятся в самом экземпляре класса.

#### Метод `renderPage()`
Основным методом данного класса является `renderPage()`, который принимает 2 аргумента - схему и данные, которые надо шаблонизировать. Сам метод является рекурсивным и 1 итерация метода возвращает 1 DOM-элемент с настроенными css-классами, атрибутами и переданным контентом. Рекурсивно вызывается, если в поле `content` схемы передан объект, массив, условие или обрабатываемый элемент является `repeater` (об этом ниже)

#### Метод `checkVariable()`
Такой способ добавления и редактирования страниц сайта, определенно, удобнее, нежели описывать "в лоб" все DOM-элементы, но ему не хватает гибкости. Поэтому, я добавил возможность передачи переменных внутри наших JSON-схем!

Метод `checkVariable()` как раз ищет строки, вида `<%some.variable%>` и возвращает булевое значение, в зависимости от наличия подобной строки в переданном аргументе.  Принимает 1 аргумент - строку, где производится поиск переменной.

#### Метод `parseVariable()`
Метод вызывается сразу после `checkVariable()` и возвращает очищенную от лишних символов строку с названием переменной. Принимает 1 аргумент - строку, откуда вырезается название переменной.

#### Метод `pickUpDataFromVariable(templateVariable, dataSource)`
Принимает название найденной переменной (`templateVariable`) и источник данных (`dataSource`), где необходимо произвести поиск данных, возвращает либо найденные данные, либо ничего.

Возможные шаблоны переменных:
+ `field.deeperField` - определяется по наличию точки в шаблоне, указывает на то, что необходимая переменная находится в поле `dataSource.field.deeperField`
+ `field.deeperField*multiplier` - определяется по наличию И точки в шаблоне И звёздочки. Находит переменную до звёздочки и умножает на значение переменной после звёздочки. Используется в корзине, где цена товара умножается на кол-во
+ `someSting+variable` - определяется по знаку "+" в шаблоне переменной, берет левую часть и подставляет её перед значением найденной переменной. Используется, чтобы формировать URL'ы к картинкам и ссылкам
+ `arrayName:index` - определяется по знаку ":" в шаблоне и указывает на порядковый номер элемента в предполагаемом массиве, находящемся в поле `dataSource.arrayName`
+ `someSting+arrayName:index` - комбинирует предыдущие два шаблона, используется, чтобы выбрать порядковый номер в массиве изображений и сформировать урл
+ `condition=result` - определяется по знаку "=" в шаблоне переменной, проверяет наличие поля `dataSource.condition`, если оно есть, возвращает правую часть из шаблона переменной - `result`
+ `varName` отсутствуют какие-либо знаки, проверяет наличие поля `dataSource.varName`, если оно есть, вернёт его значение

#### Метод `checkCondition()`
Принимает строку и проверяет её на наличие слова `if` в начале. Если оно есть, вернёт `true`, если нет - `false`. Ожидает строку вида `<%if(!!condition)%>`

#### Метод `parseCondition()`
Убирает лишние символы, возвращает вырезанную строку из круглых скобок строки

#### Метод `fulfillCondition(condition, dataSource)`
Принимает 2 аргумента, строку с условием `condition` и источник данных `dataSource`. Выполняет проверку на одно из возможных условий:
+ `!!variable` - произведёт двойное логическое отрицание и вернёт истину, если поле `dataSource.variable` существует, или ложь
+ `varOne==varTwo` - произведёт сравнение переменных с приведением типов данных, вернёт результат сравнения

#### Метод `renderPagination(itemsCount, currentPage)`
Отвечает за вывод пагинации на сайте, принимает 2 аргумента: `itemsCount` - общее кол-во элементов, `currentPage` - номер текущей страницы. Использует 1 глобальную переменную - `window.howMuchProductsShow`, которая создаётся в файле-настройках Роутера `./js/Router/Router.config.js`. Возвращает сформированный элемент пагинации по страницам, вида `page/2`.

#### Объект `repeater`
Такой объект описывает схему повторяющихся данных, получаемых из входного массива данных (список товаров, товары в корзине, список найденных товаров). Чтобы указать на наличие такого объекта, необходимо в схеме добавить поле `repeater` со значением `true`, тогда данные из поля `content` данного элемента будут применимы ко всем элементам в входных данных при инициализации функции `renderPage()`

Может использоваться определенное кол-во раз, если добавить свойство поле `repeaterCount` с указанием кол-ва повторений (может использовать переменные (фактически, на сайте используется для вывода звёздочек рейтинга))

#### Условные блоки if...else
Инициализируется в поле `content` строкой вида `<%if(!!price.saleCost)%>`. При этом, можно опустить все остальные поля, например, название тега, css-классы, атрибуты, т.к. после прохождения проверки, отрендерится либо поле `if` данного элемента, либо поле `else`

## Реализация MVC

В проекте используется реализация паттерна MVC.
К Модели относится вся `Работа с API сервера`, `View` и `Controller` находятся в папках с компонентами.

### Работа с API

Работа с серверным API полностью находится внутри файлов в директории `./js/ServerAPI/*.js`:
+ `ApiUrls.js` - собраны все необходимые URL для взаимодействия с REST API и WebSocket серверами.
+ `ApiConfig.js` - хранит в себе различные настройки, в рамках данного проекта, это настройки разных методов запросов к серверу, их хедеры и т.п.
+ `CartApi.js` - содержит все функции обращения к серверу, управляющие функционалом корзины.

#### Функционал корзины

Корзина реализована с помощью получения cookie, получаемых при обращении к серверу. Сервер запоминает сессию пользователя и обрабатывает сохранённые в Базе Данных JSON-объекты, относящиеся к тому или иному пользователю.

Для работы корзины, в файле `CartApi.js` реализованы следующие функции:
+ `addProduct()`
+ `updateProductItemQuantity()`
+ `deleteProduct()`
+ `updateCartCount()`

#### Функция `addProduct()`
Принимает 1 аргумент - id товара и отправляет `POST` запрос на сервер, в котором передаёт в JSON-строке объект с единственным полем '_id' и значением - id этого товара.

#### Функция `updateProductItemQuantity()`
Принимает 2 аргумента - id товара и настоящее количество. Делает `PUT` запрос на сервер, возвращает обновленное количество данного товара либо объект с ошибкой.

#### Функция `deleteProduct()`
Принимает 1 аргумент - id товара и отправляет `DELETE` запрос на сервер, удаляя указанный товар. Возвращает промис, который разрешится либо ответом сервера, либо ошибкой.

Все три функции имитируют внутри себя кастомное событие `updateCartCount` при успешном ответе сервера.

#### Функция `updateCartCount()`
Запрашивает на сервере общее количество товаров в корзине пользователя. Возвращает промис, который разрешится либо JSON-объектом, содержащим поле `count`, где указано общее кол-во товаров, либо объектом ошибки.

### Компоненты

Некоторые управляемые элементы настраиваются с помощью классов, отвечающих на `View` и `Controller`. Их функционал вынесен в отдельные папки и файлы и все они находятся в папке `./js/Components/`. Структура директории такова:

Components
├── Cart
│   └── CartController.js
│   └── AddToCartBtn.js
│   └── CartItem.js
│   └── CartProductsCounter.js
├── SearchPanel
│   └── SearchPanelController.js
│   └── SearchPanel.js
└── ShowProductsBy
    └── ShowProductsByController.js
    └── ShowProductsBy.js

+ `CartController.js` - контроллер, объединяет представление кнопок "Добавить в корзину", счётчиков товаров в корзине и карточек товаров при просмотре корзины и их функционала
+ `AddToCartBtn.js` - представление кнопки добавления товара в корзину.
+ `CartItem.js` - представление карточки товара в корзине.
+ `CartProductsCounter.js` - представление счётчиков товаров в корзине.

+ `SearchPanelController.js` - контроллер, в котором заключается вся логика работы с поисковой строкой, валидация введённых данных и обработка событий
+ `SearchPanel.js` - представление панели поиска по сайту.

+ `ShowProductsByController.js` - контроллер, меняющий глобальную переменную, отвечающую за лимит выводимых товаров и обрабатывающий события предствления
+ `ShowProductsBy.js` - представление лимита отображаемых товаров на странице.

Каждый компонент инициализируется путём передачи его в конструктор класса в объекте с полем `rootElement` в класс представления и инициализации в конструкторе класса представления функции, отвечающей за связку с контроллером.

#### Контроллер Корзины товароа

Класс `CartController`

Содержит в себе всю логику, связанную с корзиной, добавление/удаление/обновление товаров в ней и подсчёт актуального количества товаров внутри, обработку событий и связку с API сервера. В конструкторе создаёт пустой массив в поле `productsCounters`, для хранения счётчиков общего количества товаров в корзине.

Содержит следующие функции:

+ `addProduct(addBtn)` - принимает 1 аргумент - кнопку из представления, которой назначает обработчик события `click` - `addProductEvent`.
+ `addProductEvent` - обрабатывает события клика по кнопке, получает ID товара из дата-атрибута `productId` кнопки, проводит валидацию полученного айди и отправляет запрос к `Model`, метод `addProduct`. При успешном ответе вызывает внутреннюю функцию контроллера - `updateCounters`
+ `addProductsCounter` - принимает 1 аргумент - представление счётчика общего числа товаров и добавляет его в поле класса `productsCounters`
+ `updateProductCounters` - метод обращается к `Model` к методу `updateCartCount`. При успешном ответе вызывает у каждого элемента массива в внутреннем поле класса `productsCounters` внутренний метод `updateCounter`, куда передаёт 1 аргумент - новое кол-во товаров, для обновления представления.
+ `cartItemInit` - метод, инициализирует обработку событий на карточке товара в корзине. Обрабатывает собятия `click` на кнопке удаления товара и `input` на поле ввода количества товара. Обработчики событий прописаны прямо внутри метода, так как необходим доступ к переданному представлению. Событие клика вызывает метод из `Model` - `deleteProduct`, при успешном выполнении, вызывается метод `clearView` в представлении компонента, и внутренний метод класса контроллера `updateProductCounters`. Событие изменения поля ввода количества товаров проводит валидацию введённого числа, если оно меньше 1, то функция обработчик события прерывает свою работу, производя вызов метода `setValueToOne` из класса представления. Если валидация прошла успешно - вызывает метод из `Model` - `updateProductItemQuantity`, который при успешном разрешении вызывает метод класса представления `renderNewAmount` и внутренний метод класса контроллера `updateProductCounters`.

#### Представление Кнопки добавления товара в корзину

Класс `AddToCartBtn`

В конструкторе создаёт поле `addBtn`, куда сохраняет переданный DOM-элемент кнопки, и вызывает внутренний метод `initController`, куда передаёт объект - контроллер корзины.

Метод `initController` принимает контроллер и вызывает внутри себя метод `addProduct` с 1 аргументом - DOM-элементом кнопки.

#### Карточка товара в корзине

Класс `CartItem`

В конструкторе создаёт поля:
+ `cartItem`, куда сохраняет DOM-элемент представления карточки товара
+ `quantityFeild` - DOM-элемент количества товаров
+ `priceField` - DOM-элемент, содержащий цену товара
+ `amountResultField`  - DOM-элемент общей стоимости введённого количества данного товара

В конструкторе вызывает внутренний метод `initController`, куда передаёт объект контроллера корзины.

Имеет 4 метода:
+ `initController` - инициализирует контроллер на представлении
+ `clearView` - удаляет данный компонент со страницы
+ `setValueToOne` - устанавливает значение в поле `quantityFeild` на 1
+ `renderNewAmount` - рендерит общую цену товаров в зависимости от их количества

#### Счётчик товаров в корзине

Класс `CartProductsCounter`


В конструкторе создаёт поле `cartCounter`, куда сохраняет DOM-элемент представления и вызывает внутренний метод `initController`, куда передаёт объект контроллера корзины.

Метод `initController` принимает контроллер и вызывает 2 метода контроллера:
+ `addProductsCounter` с 1 аргументом - объектом класса представления
+ `updateProductCounters` для обновления инициализированных счётчиков

Имеет 1 метод - `updateCounter`, который принимает 1 аргумент - новое количество товаров в счётчике и обновляет представление.

#### Контроллер Поиска по сайту

Класс `SearchPanelController`

Содержит 3 метода:
+ `searchPanelInit` - принимает объект класса представления, получает из него поле ввода и кнопку отправки. Назначает внутри себя обработчики событий `input` и `keypress` на поле ввода и `click` на кнопке отправки. Обработчик события `input` проводит валидацию введённых данных, если поле пустое или заполнено пробелами, вызывает метод `clearValidation` у объекта представления, если поле заполнено не верно, вызывает метод `setInvalid` у объекта представления, иначе - вызывает метод `setValid` у объекта представления. Обработчик событий `keypress` и `click` вызывают внутренний метод класса `searchQueryFieldIsValid` в который пердаются введённые данные, он проводит валидацию и возвращает логическое значение. При прохождении валидации, обработчики вызывают внутренний метод `approveSearch`.
+ `searchQueryFieldIsValid` - метод принимает 1 аргумент - введёные данные, и проводит валидацию. Возвращает логическое значение.
+ `approveSearch` - метод "разрешает" совершить переход по заданному поисковому запросу и вызывает метод `goToSearchPage` у объекта предствления, куда передаёт подготовленный queryString, содержащий поисковой запрос.

#### Поиск по сайту

Класс `SearchPanel`

Класс инициализируется на родительском элементе, имеющем класс `.search-panel`, внутри класса создаются поля:
+ `rootElement` - DOM-элемент, на котором производится инициализация класса.
+ `inputField` - поле ввода запроса.

Класс содержит следующие методы:
+ `initController` - инициализирует контроллер на компоненте.
+ `clearValidation` - удаляет css-классы, отвечающие за валидность поля.
+ `setInvalid` - задаёт классы, устанавливая поле не валидным.
+ `setValid` - задаёт классы, устанавливая поле валидным.
+ `goToSearchPage` - принимает 1 аргумент - queryString (подготовленный "хвост" для адресной строки, содержащий поисковой запрос) и вызывает метод роутера `navigate`, куда передаёт аргумент, очищает поле ввода и вызывает внутренний метод класса представления `clearValidation`.

Для осуществления поискового запроса, поле поиска должно быть валидным. Оно считается не валидным если длина введённого значения меньше 4 символов. Заполненное поле пробелами так же считается не валидным.

При правильном заполнении, функция не производит запроса к серверу, она перенаправляет нас на роут `/search` с переданным в неё текстом запроса. А роут уже сам обращается к серверу за нужными данными.

#### Контроллер Лимита отображаемых заказов

Класс `ShowProductsByController`

Имеет 1 метод - `showProductsBylInit`, который принимает объект класса представления. Выделяет из переданного аргумента поле, содержащее DOM-элемент компонента и назначает на него обработку события `change`, иницициализируя обработчик прямо в теле метода. В обработчике выделяется новое значение компонента, переопределяется новое значение глобальной переменной `howMuchProductsShow`, куда передаётся обновлённое значение компонента и вызывается метод объекта класса представления `updatePage`

#### Лимит отбражаемых товаров

Класс `ShowProductsByList`

Популярный функционал интернет-магазинов, когда на каждой странице пагинации отображается нужное кол-во товаров. В нашем случае, их может быть 6, 9 или 12

В конструкторе класса сохраняет в поле `optionsList` DOM-элемент представления и вызывает внутренний метод `initController`, куда передаёт объект класса контроллера.

Содержит 2 метода:
+ `initController` - передаёт объект класса представления в метод `showProductsBylInit` объекта класса контроллера
+ `updatePage` - вызывет метод Роутера `check`, обновляя страницу

### Чат с администратором магазина

Для организации чата администратора с посетителями, мною был настроен WebSocket-сервер, который раздаёт пользователям порядковые номера (иммитация id) и уже по ним определяет, от кого куда нужно доставлять сообщения. Пользователь может написать администратору или получить от него сообщение. А администратор может только отвечать всем пользователям, которые написали в чат. До этого, администратор не может свободно писать пользователям.

WebSocket-сервер принимает и отправляет кастомные объекты, в которых могут быть поля:
+ `eventId` - обязательное, определяет тип события. Строка
+ `setIsAdmin` - устанавливает данного пользователя, как администратора
+ `message` - сообщение
+ `targetId` - используется администратором для идентификации получателя сообщения

С клиента на сервер мы можем отправить следующие события:
+ `setIsAdmin` - устанавливает администратора
+ `newMessage` - новое сообщение
+ `startTyping` - пользователь пишет
+ `stopTyping` - пользователь прекратил писать

А с сервера могут прийти такие события:
+ `incomingMessage` - входящее сообщение
+ `closeСonnection` - закрытие соединения

Реализация находится в файлах:
+ `./js/Chat/ShopChat.js` - кастомные методы
+ `./js/Chat/ChatClientSide` - реализация чата для пользователей
+ `./js/Chat/ChatAdminSide` - реализация чата для администраторов

#### Расширение прототипа класса WebSocket
При работе, мною сперва был создан собственный класс ShopChat, который должен был наследовать все методы и свойства от класса WebSocket, но он возвращал экземпляры класса WebSocket. Поэтому, мною было принято решение добавить методы в класс WebSocket.
+ `sendStringify(data)` - использует встроенный в WebSocket метод `send()`, передаёт в него JSON-строку из, созданную из переданного аргумента.
+ `setIsAdmin()` - отправляет на сервер готовый объект с нужным кастомынм идентификатором события. Не принимает аргументов и ничего не возвращает. Сервер сам установит нужное соединение в состояние `setIsAdmin`
+ `sendMessage(message, targetId)` - Принимает два аргумента - текст сообщения и целевой id(не обязательно). Формирует и отправляет на сервер подготовленный объект.
+ `startTyping(targetId)` - отправляет на сервер готовый объект события `startTyping`. Принимает 1 аргумент - id пользователя
+ `stopTyping(targetId)` - отправляет на сервер готовый объект события `stopTyping`. Принимает 1 аргумент - id пользователя

#### Прочие функции
+ preloader.show()/hide() - отвечает за отображение и скрытие прелодера, методы добавлены в сам DOM-элемент