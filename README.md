Дипломный проект курса JavaScript
===

`Прим. Back-end часть сайта располагается на herokuapp, который переходит в режим sleep при долгом "простое". Поэтому, при первичном обращении к GithubPages может показаться, что что-то сломалось, т.к. товары на страницу будут загружаться долго`

В рамках дипломной работы по курсу Нетологии "JavaScript в браузере: создаем интерактивные веб-страницы" была выбрана задача - реализовать функционал интернет-магазина:

1. Загрузка товаров в виде `JSON-объектов` с удалённого сервера с помощью `REST API`
2. Парсинг входящих объектов и генерация HTML-разметки с помощью `DOM API`
3. Добавление\удаление товаров из корзины с помощью Back-end части приложения, основываясь на сессиях с помощью `Cookie`
4. Создание административной странички сайта с возможностью отвечать на чат-сообщения, получаемые через `WebSocket-соединение`
5. Реализовать поисковую строку на сайте с возможностью голосового поиска, основываясь на `MediaStream Recording API` технологии Яндекса `SpeechKit`

## Проектирование

Если опускать этап настройки Back-end части моего проекта, то на этапе проектирования Front-end части я выяснил, что для более качественной реализации поставленных задач, мне необходимо:
+ Найти и подготовить HTML-шаблон
+ Настроить маршрутиризатор (Класс Router)
+ Сделать шаблонизатор (Класс TemplateEngine)
+ Создать схемы страниц для шаблонизации
+ Реализовать функционал корзины
+ Сделать возможность отображения по 6, 9 и 12 товаров на странице
+ Настроить пагинацию
+ Разделить чаты на Клиентов и Администратора
+ Настроить Яндекс SpeechKit API
+ Настроить дополнительные события

### Подготовка html-шаблона

Для придания достойного внешнего вида и сокращения энерго-временных затрат на вёрстку, для реализации учебного проекта были взяты страницы шаблона `htmlnewlook` с сайта `ThemeForest.net`, а именно страницы:
1. Вывод товаров в сетке - http://htmlnewlook.justthemevalley.com/shop_grid.html
2. Корзина товаров - http://htmlnewlook.justthemevalley.com/shopping_cart.html
3. Поиск товаров - http://htmlnewlook.justthemevalley.com/shop_list.html
4. Просмотр конкретного товара - http://htmlnewlook.justthemevalley.com/single_product.html

Далее, шаблон был очищен от ссылок, верхнее меню, правый сайдбар и ссылки в футере ведут на '/' страницу. Были удалены все `JavaScript` файлы и набор товаров был переведён в JSON формат и погружён на сервер.

### Класс `Router`

Файл `./js/Router/Router.js`

На создание роутинга по такому принципу меня вдохновила статья зарубежного коллеги Krasimir Tsonev, который в своём блоге рассказывает, как он готовит собственный фреймворк на `JavaScript`. Большая часть кода роутера взята из его примеров, но очищена от лишнего кода и доработана в соответствии с задачей проекта.

Конструктор класса не принимает аргументов и создаёт экземпляр с следующими полями:
+ `routes`
+ `root`

И обладает следующими методами:
+ `getFragment()`
+ `clearSlashes(path)`
+ `add(re, handler)`
+ `check(f)`
+ `listen()`
+ `navigate(path)`
+ `pickUpLinks()`

(при эксплуатации класса возникла необходимость создать вспомогательную функцию `sendLinkToRouter`, которая используется, как обработчик события клика по ссылке и создана с целью избежания утечки памяти)

#### Поле `routes` 
Хранит в себе все обрабатываемые адреса, добавленные методом `add()`.

#### Поле `root` 
Хранит в себе адрес корня сайта, от которого рассчитываются все заданные маршруты.

#### Метод `getFragment()`
Служит вспомогательной функцией, которая получает фрагмент того маршрута, на котором пользователь находится в данный момент и использует другой метод класса - `clearSlashes()`. Не принимает аргументов.

#### Метод `clearSlashes(path)`
Метод очищает полученный URI от слешей в начале и конце, и возвращает очищенную строку. Принимает 1 аргумент - URI без домена, порта и протокола.

#### Метод `add()`
Метод добавляет в массив поля `routes` объект и возвращает обновлённый экземпляр класса.

Принимает 2 аргумента:
+ `re` - маршрут
+ `handler` - обработчик маршрута

По умолчанию, если первым аргументом передана функция, то она используется, как обработчик для роута, относящегося к корневому маршруту.

#### Метод `check(f)`
Метод служит для того, чтобы проверить изменения на странице. Принимает 1 не обязательный аргумент - фрагмент урл, который необходимо проверить, находит его в массиве поля `routs` данного экземпляра класса и вызывает его обработчик к данному маршруту.

#### Метод `listen()`
С интервалом в 50 миллисекунд проверяет изменения в настоящем маршруте. Если URL изменился, перерисовывает страницу, вызывая обработчик настоящего маршрута.

#### Метод `navigate(path)`
Метод перенаправляет на переданный в него путь. Используется для обработки кликов по ссылкам.

#### Метод `pickUpLinks()`
Обрабатывает ссылки на странице сайта и назначает им обработчик `sendLinkToRouter`

#### Функция `sendLinkToRouter(event)`
Отменяет переход по ссылке по умолчанию и передаёт правую часть целевого урла в метод `navigate()` экземпляра класса.

### Настройки класса `Router`

Создание и настройка экземпляра класса производится в отдельном файле `./js/Router/Router.config.js`
Здесь определен корневой элемент приложения, он имеет идентификатор `app`, внутри которого будет отображаться весь контент, обрабатываемый нашим маршрутиризатором. Так же, реализован метод `appBlock.makeEmpty`, очищающий корневой элемент приложения от всех потомков. 

Инициализирована глобальная переменная `window.howMuchProductsShow`, которая, по умолчанию, равна 6 и служит для определения количества товаров, выводимых при рендеринге на странице.

Настройка самого экземпляра класса `Router` происходит после наступления события `DOMContentLoaded`, чтобы всё DOM-дерево было успешно сформировано и все скрипты подключены к документу.

По умолчанию, при заходе на сайт, роутер перенаправляет на страницу `/page/1`, где выводится первая часть товаров. Товары загружаются в JSON формате с удалённого сервера. Сервер настроен таким образом, что при обращении к адресу `http://localhost:3000/api/v1/goods` мы получим не больше 6 товаров. 

Мы можем передать следующие параметры в строке запроса:
+ limit - ограничивает кол-во отдаваемых товаров за 1 запрос
+ offset - показывает, сколько нужно пропустить товаров от начала списка
+ count - возвращает только общее кол-во товаров (необходимо для пагинации)
+ search - осуществляет поиск по переданным словам (не по запросу целиком, а по каждому переданному слову)

Обрабатываются следующие виды адресов:
+ `/goods/:goodId`, где goodId - числовой идентификатор товара. Служит для просмотра конкретных товаров
+ `/cart/` - отображает корзину товаров
+ `/page/:pageNum`, где pageNum - числовой идентификатор страницы. Служит, как параметр offset, при обращении к API и нужен для пагинации (если она требуется)
+ `/search/` - для отображения результатов поиска

Каждый роут добавлен с помощью метода `add()` и использует Шаблонизатор.

Все используемые URL вынесены в отдельный файл `./js/Router/Router.urls.js`

### Класс `TemplateEngine`

Файл `./js/TemplateEngine/TemplateEngine.js`

Идея создания шаблонизатора пришла сразу, т.к. использование DOM API в классическом его представлении превращается в тяжелочитаемый и трудноподдерживаемый код. Пропадает удобство использования и усложняется масштабируемость проектов.

Конструктор класса принимает 1 аргумент, путь до папки с схемами шаблонов, и создаёт экземпляр с следующими полями:
+ `schemasFolder`
+ `schemas`

Обладает следующими методами:
+ `addSchema(schemaObject)`
+ `renderPage(schema, renderedData)`
+ `checkVariable(partOfContent)`
+ `parseVariable(partOfContent)`
+ `pickUpDataFromVariable(partOfContent)`
+ `checkCondition(partOfContent)`
+ `parseCondition(partOfContent)`
+ `fulfillCondition(condition, dataSource)`
+ `renderPagination(itemsCount, currentPage)`

#### Требования к JSON-схемам

К JSON-схемам есть требования:
1. Корневой элемент должен быть объектом
2. Названия тегов передаются в виде строки в поле `tagName`
3. Названия классов передаются либо строкой, либо массивом строк в поле `className`
4. Атрибуты передаются в виде объекта, где название поля - имя атрибута, а значение - его значение, передаются в поле `attributes`
5. Если в теге должен быть id, то он передаётся в виде строки отдельным полем `id`
6. Контент тега передаётся в поле `content` в виде строки, тогда будет подставлен, как textNode, либо в виде объекта, либо в виде массива строк/объектов. Вложенные друг в друга теги передаются объектом в поле `content`

#### Метод `addSchema()`
При создании экземпляра класса TemplateEngine я указываю путь до JSON-схем с описанием наших страничек сайта, чтобы сократить урлы при добавлении каждой схемы. После создания экземпляра класса, нужно добавить объекты схем с двумя полями:
1. `name`
2. `url`

Это производится методом `addSchema()` в файле `./js/TemplateEngine/TemplateEngine.config.js`. После добавления схем, из названия и пути к ним хранятся в самом экземпляре класса.

#### Метод `renderPage()`
Основным методом данного класса является `renderPage()`, который принимает 2 аргумента - схему и данные, которые надо шаблонизировать. Сам метод является рекурсивным и 1 итерация метода возвращает 1 DOM-элемент с настроенными css-классами, атрибутами и переданным контентом. Рекурсивно вызывается, если в поле `content` схемы передан объект, массив, условие или обрабатываемый элемент является `repeater` (об этом ниже)

#### Метод `checkVariable()`
Такой способ добавления и редактирования страниц сайта, определенно, удобнее, нежели описывать "в лоб" все DOM-элементы, но ему не хватает гибкости. Поэтому, я добавил возможность передачи переменных внутри наших JSON-схем!

Метод `checkVariable()` как раз ищет строки, вида `<%some.variable%>` и возвращает булевое значение, в зависимости от наличия подобной строки в переданном аргументе.  Принимает 1 аргумент - строку, где производится поиск переменной.

#### Метод `parseVariable()`
Метод вызывается сразу после `checkVariable()` и возвращает очищенную от лишних символов строку с названием переменной. Принимает 1 аргумент - строку, откуда вырезается название переменной.

#### Метод `pickUpDataFromVariable(templateVariable, dataSource)`
Принимает название найденной переменной (`templateVariable`) и источник данных (`dataSource`), где необходимо произвести поиск данных, возвращает либо найденные данные, либо ничего.

Возможные шаблоны переменных:
+ `field.deeperField` - определяется по наличию точки в шаблоне, указывает на то, что необходимая переменная находится в поле `dataSource.field.deeperField`
+ `field.deeperField*multiplier` - определяется по наличию И точки в шаблоне И звёздочки. Находит переменную до звёздочки и умножает на значение переменной после звёздочки. Используется в корзине, где цена товара умножается на кол-во
+ `someSting+variable` - определяется по знаку "+" в шаблоне переменной, берет левую часть и подставляет её перед значением найденной переменной. Используется, чтобы формировать URL'ы к картинкам и ссылкам
+ `arrayName:index` - определяется по знаку ":" в шаблоне и указывает на порядковый номер элемента в предполагаемом массиве, находящемся в поле `dataSource.arrayName`
+ `someSting+arrayName:index` - комбинирует предыдущие два шаблона, используется, чтобы выбрать порядковый номер в массиве изображений и сформировать урл
+ `condition=result` - определяется по знаку "=" в шаблоне переменной, проверяет наличие поля `dataSource.condition`, если оно есть, возвращает правую часть из шаблона переменной - `result`
+ `varName` отсутствуют какие-либо знаки, проверяет наличие поля `dataSource.varName`, если оно есть, вернёт его значение

#### Метод `checkCondition()`
Принимает строку и проверяет её на наличие слова `if` в начале. Если оно есть, вернёт `true`, если нет - `false`. Ожидает строку вида `<%if(!!condition)%>`

#### Метод `parseCondition()`
Убирает лишние символы, возвращает вырезанную строку из круглых скобок строки

#### Метод `fulfillCondition(condition, dataSource)`
Принимает 2 аргумента, строку с условием `condition` и источник данных `dataSource`. Выполняет проверку на одно из возможных условий:
+ `!!variable` - произведёт двойное логическое отрицание и вернёт истину, если поле `dataSource.variable` существует, или ложь
+ `varOne==varTwo` - произведёт сравнение переменных с приведением типов данных, вернёт результат сравнения

#### Метод `renderPagination(itemsCount, currentPage)`
Отвечает за вывод пагинации на сайте, принимает 2 аргумента: `itemsCount` - общее кол-во элементов, `currentPage` - номер текущей страницы. Использует 1 глобальную переменную - `window.howMuchProductsShow`, которая создаётся в файле-настройках Роутера `./js/Router/Router.config.js`. Возвращает сформированный элемент пагинации по страницам, вида `page/2`.

#### Объект `repeater`
Такой объект описывает схему повторяющихся данных, получаемых из входного массива данных (список товаров, товары в корзине, список найденных товаров). Чтобы указать на наличие такого объекта, необходимо в схеме добавить поле `repeater` со значением `true`, тогда данные из поля `content` данного элемента будут применимы ко всем элементам в входных данных при инициализации функции `renderPage()`

Может использоваться определенное кол-во раз, если добавить свойство поле `repeaterCount` с указанием кол-ва повторений (может использовать переменные (фактически, на сайте используется для вывода звёздочек рейтинга))

#### Условные блоки if...else
Инициализируется в поле `content` строкой вида `<%if(!!price.saleCost)%>`. При этом, можно опустить все остальные поля, например, название тега, css-классы, атрибуты, т.к. после прохождения проверки, отрендерится либо поле `if` данного элемента, либо поле `else`

### Функционал корзины

Корзина реализована с помощью получения cookie, получаемых при обращении к серверу. Сервер запоминает сессию пользователя и обрабатывает сохранённые в Базе Данных JSON-объекты, относящиеся к тому или иному пользователю.

Для работы корзины, в файле `./js/Events.js` реализованы следующие функции:
+ `addGoodInCart()`
+ `updateProductsCount()`
+ `deleteProduct()`

#### Функция `addGoodInCart()`
Назначается, как обработчик кликов по кнопкам "Добавить в корзину", получает id товара из поля `data-product-id` и отправляет `POST` запрос на сервер, в котором передаёт в JSON-строке объект с единственным полем '_id' и значением - id этого товара

#### Функция `updateProductsCount()`
Назначается, как обработчик события `input` на полях с количеством товара в корзине. Меняет само значение тега input, производит перерасчёт итоговой стоимости данного товара, отправляет `PUT` запрос на сервер, в котором передаёт  в JSON-строке объект с полями "_id" и "count" - id товара и его итоговым количеством.

#### Функция `deleteProduct()`
Назначается, как обработчик кликов на кнопки "удалить" в корзине, отправляет на сервер `DELETE` запрос, в котором передаёт в JSON-строке объект с единственным полем '_id' и значением - id этого товара

### Количество отбражаемых товаров

Популярная функция, когда на каждой странице пагинации отображается нужное кол-во товаров. В нашем случае, их может быть 6, 9 или 12 и управление происходит с помощью функции `changeShowBy(event)`, которая назначается обработчиком события `change` на соответствующем `<select>` элементе сайта. Функция извлекает новое значение из селекта, сохраняет его в глобальной переменной `window.howMuchProductsShow` и производит перерисовку страницы с помощью метода `check()` экземпляра класса `Router`

### Поиск по сайту

Изначально задумывалось сделать голосовой поиск по сайту с помощью технологии Яндекса `SpeechKit`, но их сервер не возвращает корректные значения, при разработке в локальной среде (а может и не только, ответ от них так и не пришёл). Но добавление данного способа не позволило бы затронуть MediaRecorder API, поэтому, не страшно, что попытка не увенчалась успехом.

В рабочем варианте проекта поиск по товарам осуществляется с помощью функции `search()`, которая назначается обработчиком событий `click`, `keypress` и `input`. Первые два события используются непосредственно для осуществления поиска, а событие `input` - для валидации. Функция `search()` использует всплытие событий, поэтому, она одна выполняет весь необходимый функционал, требуемый для поисковой строки.

Для осуществления поискового запроса, поле поиска должно быть валидным. Оно считается не валидным если длина введённого значения меньше 4 символов. Заполненное поле пробелами так же считается не валидным.

При правильном заполнении, функция не производит запроса к серверу, она перенаправляет нас на роут `/search` с переданным в неё текстом запроса. А роут уже сам обращается к серверу за нужными данными.

### Чат с администратором магазина

Для организации чата администратора с посетителями, мною был настроен WebSocket-сервер, который раздаёт пользователям порядковые номера (иммитация id) и уже по ним определяет, от кого куда нужно доставлять сообщения. Пользователь может написать администратору или получить от него сообщение. А администратор может только отвечать всем пользователям, которые написали в чат. До этого, администратор не может свободно писать пользователям.

WebSocket-сервер принимает и отправляет кастомные объекты, в которых могут быть поля:
+ `eventId` - обязательное, определяет тип события. Строка
+ `setIsAdmin` - устанавливает данного пользователя, как администратора
+ `message` - сообщение
+ `targetId` - используется администратором для идентификации получателя сообщения

С клиента на сервер мы можем отправить следующие события:
+ `setIsAdmin` - устанавливает администратора
+ `newMessage` - новое сообщение
+ `startTyping` - пользователь пишет
+ `stopTyping` - пользователь прекратил писать

А с сервера могут прийти такие события:
+ `incomingMessage` - входящее сообщение
+ `closeСonnection` - закрытие соединения

Реализация находится в файлах:
+ `./js/Chat/ShopChat.js` - кастомные методы
+ `./js/Chat/ChatClientSide` - реализация чата для пользователей
+ `./js/Chat/ChatAdminSide` - реализация чата для администраторов

#### Расширение прототипа класса WebSocket
При работе, мною сперва был создан собственный класс ShopChat, который должен был наследовать все методы и свойства от класса WebSocket, но он возвращал экземпляры класса WebSocket. Поэтому, мною было принято решение добавить методы в класс WebSocket.
+ `sendStringify(data)` - использует встроенный в WebSocket метод `send()`, передаёт в него JSON-строку из, созданную из переданного аргумента.
+ `setIsAdmin()` - отправляет на сервер готовый объект с нужным кастомынм идентификатором события. Не принимает аргументов и ничего не возвращает. Сервер сам установит нужное соединение в состояние `setIsAdmin`
+ `sendMessage(message, targetId)` - Принимает два аргумента - текст сообщения и целевой id(не обязательно). Формирует и отправляет на сервер подготовленный объект.
+ `startTyping(targetId)` - отправляет на сервер готовый объект события `startTyping`. Принимает 1 аргумент - id пользователя
+ `stopTyping(targetId)` - отправляет на сервер готовый объект события `stopTyping`. Принимает 1 аргумент - id пользователя